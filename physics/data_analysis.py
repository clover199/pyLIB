from __future__ import absolute_import, division, print_function
import numpy as np
from scipy.interpolate import splrep, splev
from time import time
import matplotlib.pyplot as plt

"""
This file defines useful functions to do simple data analysis for physics problems
"""


def trial_and_test(filename, model, points=20, ratio=0.2, alpha=None):
    """
    A trial and test scheme to find the phase transition point.
    We keep the training data balanced.
    Only used for physics problems
    input:  filename    data file name, no suffix
            model       a model for classification with methods: fit, score
            points      number of points to take as transition point
            ratio       ratio of number of data used for each critical point
            alpha       used to determine the response value, default None.
                        If None, use step function, i.e. class label.
                        Otherwise y=1/(1+exp(alpha)).
    output:             a 2D array with columns [ts, train accuracy, test accuracy]
    """
    print("Load data from {:s}.npz".format(filename))
    with np.load("{:s}.npz".format(filename)) as load:
        data = load['data']
        ts = load['ts']
    print("training data shape ({:.0f},{:d})".format(data.shape[0]*ratio*0.7, data.shape[1]))

    tmin = min(ts)
    tmax = max(ts)
    gap = (tmax-tmin)*ratio*0.5
    tcs = np.linspace(tmin+gap,tmax-gap, points, endpoint=True)
    errs = np.zeros([tcs.shape[0],3])
    errs[:,0] = tcs
    begin = time()
    for i, tc in enumerate(tcs):
        print("Point", i+1, end='\r')
        if alpha is None:
            y = np.where(ts<tc, 1, 0).ravel()
        else:
            y = 1/( 1+np.exp( alpha*(ts-tc)/gap ) )
        arg = np.argwhere((ts<tc+gap)&(ts>tc-gap)).ravel()
        np.random.shuffle(arg)
        n = int(arg.shape[0]*0.7)
        train = arg[:n]
        test = arg[n:]
        model.fit(data[train,:], y[train])
        errs[i,1] = model.score(data[train,:], y[train])
        errs[i,2] = model.score(data[test,:], y[test])
    print("Total time used: {:2f} s".format(time()-begin))

    print("Make plots")
    plt.plot(tcs, errs[:,1], 'o-', label='training')
    plt.plot(tcs, errs[:,2], 'o-', label='testing')
    plt.legend(loc='best')
    plt.xticks(fontsize=14)
    plt.ylabel('Accuracy', fontsize=16)
    plt.yticks(fontsize=14)
    plt.tight_layout()
    return errs


def trial_and_test2(filename, model, points=20, regression=False, alpha=10):
    """
    A trial and test scheme to find the phase transition point.
    All data are used for each training, so the data can be unbalanced near edges
    Only used for physics problems
    input:  filename    data file name, no suffix
            model       a model for classification with methods: fit, score
            points      number of points to take as transition point
            alpha       used to determine the response value, default None.
                        If None, use step function, i.e. class label.
                        Otherwise y=1/(1+exp(alpha)).
    output:             a 2D array with columns [ts, train accuracy, test accuracy]
    """

    print("Load data from {:s}.npz".format(filename))
    with np.load("{:s}.npz".format(filename)) as load:
        data = load['data']
        ts = load['ts']

    tmin = min(ts)
    tmax = max(ts)
    dt = (tmax-tmin)*0.1
    tcs = np.linspace(tmin+dt,tmax-dt, points, endpoint=True)
    errs = np.zeros([tcs.shape[0],3])
    errs[:,0] = tcs
    begin = time()
    arg = np.arange(data.shape[0])
    for i, tc in enumerate(tcs):
        print("Point", i+1, end='\r')
        if alpha is None:
            y = np.where(ts<tc, 1, 0).ravel()
        else:
            y = 1/( 1+np.exp( alpha*(ts-tc)/gap ) )
        np.random.shuffle(arg)
        n = int(arg.shape[0]*0.7)
        train = arg[:n]
        test = arg[n:]
        model.fit(data[train,:], y[train])
        errs[i,1] = model.score(data[train,:], y[train])
        errs[i,2] = model.score(data[test,:], y[test])
    print("Total time used: {:2f} s".format(time()-begin))

    print("Make plots")
    plt.plot(tcs, errs[:,1], 'o-', label='training')
    plt.plot(tcs, errs[:,2], 'o-', label='testing')
    plt.legend(loc='best')
    plt.xticks(fontsize=14)
    plt.ylabel('Accuracy', fontsize=16)
    plt.yticks(fontsize=14)
    plt.tight_layout()
    return errs


def find_best_critical(filename, points=50):
    """
    A trial and test scheme to find the phase transition point using indicating variable.
    Must use the data generated by generate_data2.
    Accuracy is calculated based on 'data2' and 'ts'.
    Only used for physics problems
    input:  filename    data file name, no suffix
            points      number of points to take as transition point
    output:             a 2D array with columns [ts, accuracy]
    """

    print("Load data from {:s}.npz".format(filename))
    with np.load("{:s}.npz".format(filename)) as load:
        data = load['data2']
        ts = load['ts']

    tmin = min(ts)
    tmax = max(ts)
    tcs = np.linspace(tmin,tmax, points, endpoint=True)
    errs = np.zeros([tcs.shape[0],2])
    errs[:,0] = tcs
    for i, tc in enumerate(tcs):
        y = np.where(ts<tc, 1, 0).ravel()
        y_hat = np.where(data<0.5,0,1).ravel()
        errs[i,1] = np.mean(y==y_hat)

    print("Make plots")
    plt.plot(tcs, errs[:,1], 'o-')
    plt.xticks(fontsize=14)
    plt.ylabel('Accuracy', fontsize=16)
    plt.yticks(fontsize=14)
    plt.tight_layout()
    return errs


def classify_and_predict(filename, model, tmin=None, tc=None, tmax=None, alpha=None):
    """
    Classify and predict with randomly separated train and test.
    Only used for physics problems.
    input:  filename    data file name, no suffix
            model       a model for classification with methods: fit, score, predict_proba
            tmin        minimum value of parameter
            tc          critical point value
            tmax        maximum value of parameter
            alpha       used to determine the response value, default None.
                        If None, use step function, i.e. class label.
                        Otherwise y=1/(1+exp(alpha)).
    output:             the trained model
    """
    print("Load data from {:s}.npz".format(filename))
    with np.load("{:s}.npz".format(filename)) as load:
        data = load['data']
        ts = load['ts']

    if tmin is None:
        tmin = np.min(ts)
    if tc is None:
        tc = np.mean(ts)
    if tmax is None:
        tmax = np.max(ts)
    print("Parameter rangs from {:.2f} to {:.2f} with transition point at {:.2f}".format(tmin, tmax, tc))

    if alpha is None:
        y = np.where(ts<tc, 1, 0).ravel()
    else:
        y = 1/( 1+np.exp( alpha*(ts-tc)/(tmax-tmin) ) )
    arg = np.argwhere( (tmin<=ts) & (ts<=tmax) ).ravel()
    np.random.shuffle(arg)
    n = int(arg.shape[0]*0.7)
    train = arg[:n]
    test = arg[n:]
    model.fit(data[train,:], y[train])
    print("training data shape", data[train,:].shape, "score", model.score(data[train,:], y[train]))
    print("testing data shape ", data[test,:].shape, "score", model.score(data[test,:], y[test]))

    if alpha is None:
        result = model.predict_proba(data)
        plt.plot(ts[train], result[train,1], 'o', alpha=0.5, label='train')
        plt.plot(ts[test], result[test,1], 'o', alpha=0.5, label='test')
    else:
        result = model.predict(data)
        plt.plot(ts[train], result[train], 'o', alpha=0.5, label='train')
        plt.plot(ts[test], result[test], 'o', alpha=0.5, label='test')
    plt.legend(loc='best')
    return model


def predict_transition(filename, model, tmin=None, t1=None, t2=None, tmax=None):
    """
    Classify with data deep in phase and predict near transition point.
    A plot of the predictions is made with a fitted smooth transition line.
    Only used for physics problems.
    input:  filename    data file name, no suffix
            model       a model for classification with methods: fit, score, predict_proba
            tmin        minimum value of parameter, default None
                        If None, take the minimum value in ts
            t1          first cutoff value of parameter, default None
                        If None, take the first quartile in ts
            t2          second cutoff value of parameter, default None
                        If None, take the third quartile in ts
            tmax        maximum value of parameter, default None
                        If None, take the maximum value in ts
    output:             the trained model
    """
    print("Load data from {:s}.npz".format(filename))
    with np.load("{:s}.npz".format(filename)) as load:
        data = load['data']
        ts = load['ts']

    if tmin is None:
        tmin = np.min(ts)
    if tmax is None:
        tmax = np.max(ts)
    if t1 is None:
        t1 = (tmax-tmin)/4.0 + tmin
    if t2 is None:
        t2 = tmax - (tmax-tmin)/4.0
    print("Train with rangs from {:.2f} to {:.2f} and from {:.2f} to {:.2f}".format(tmin, t1, t2, tmax))

    tc = (t1+t2)/2.0
    y = np.where(ts<tc, 1, 0).ravel()
    arg = ((tmin<=ts) & (ts<=t1)) | ((t2<=ts) & (ts<=tmax))
    begin = time()
    model.fit(data[arg,:], y[arg])
    print("Time used for training: {:.2f} s".format(time()-begin) )
    print("training data shape", data[arg,:].shape, "score", model.score(data[arg,:], y[arg]))

    result = model.predict_proba(data)
    plt.plot(ts, result[:,1], 'o', alpha=0.5)
    plt.axvspan(tmin, t1, facecolor="k", alpha=0.2)
    plt.axvspan(t2, tmax, facecolor="k", alpha=0.2)
    spl = splrep(ts, result[:,1], t=np.linspace(tmin, tmax, 20, endpoint=True)[1:-2])
    x = np.linspace(tmin, tmax, 10000, endpoint=True)
    y = splev(x, spl)
    plt.plot(x, y, '-', lw=2)
    print("Transition happens at", x[np.argmin(np.abs(y-0.5))])
    return model


if __name__=="__main__":
    import argparse
    import data_analysis
    from inspect import getmembers, isfunction

    parser = argparse.ArgumentParser(description="Functions to generate data")
    parser.add_argument('--list', type=bool, nargs='?', const=1, default=0, \
                        help='list all available modules')
    parser.add_argument('--doc', type=str, \
                        help='print documents of given function')
    FLAGS, unparsed = parser.parse_known_args()
    if FLAGS.list:
        for x in getmembers(data_analysis, isfunction):
            print(x[0])
        exit()
    if not FLAGS.doc is None:
        print(getattr(data_analysis, FLAGS.doc).__doc__)
